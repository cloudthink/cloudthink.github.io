{"meta":{"title":"CloudThink","subtitle":null,"description":null,"author":"Zychen","url":"https://cloudthink.github.io"},"pages":[{"title":"","date":"2019-01-30T10:29:43.555Z","updated":"2019-01-30T10:29:43.551Z","comments":true,"path":"home/index.html","permalink":"https://cloudthink.github.io/home/index.html","excerpt":"","text":"CloudThinkhttps://github.com/cloudthink"},{"title":"about","date":"2019-01-30T09:58:08.675Z","updated":"2019-01-30T09:58:08.663Z","comments":true,"path":"about/index.html","permalink":"https://cloudthink.github.io/about/index.html","excerpt":"","text":"Who am I?"}],"posts":[{"title":"Amazon商品信息爬虫","slug":"Amazon商品信息爬虫(Python+Selenium)","date":"2019-01-29T10:00:40.000Z","updated":"2019-01-30T10:27:20.902Z","comments":true,"path":"2019/01/29/Amazon商品信息爬虫(Python+Selenium)/","link":"","permalink":"https://cloudthink.github.io/2019/01/29/Amazon商品信息爬虫(Python+Selenium)/","excerpt":"","text":"### 1.环境配置 Ubuntu16.04 python3 Chrome以及与之对应的chromedriver Selenium 版本参考：chromedriver下载地址 2.代码1.在selenium中使用代理，在Ubuntu中设置sock5代理端口123from selenium.webdriver.chrome.options import Optionschrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--proxy-server=socks5://127.0.0.1:1080') 2.爬虫类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165# coding: utf-8\"\"\"\"\"\"from __future__ import print_function, divisionimport timeimport sysimport pandas as pdfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport randomchrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--proxy-server=socks5://127.0.0.1:1080')#reload(sys)#sys.setdefaultencoding(\"utf-8\")class Spider(object): def __init__(self): self.options = Options() self.options.add_argument('--headless') #q1(2) self.driver = webdriver.Chrome(chrome_options=chrome_options,executable_path=\"chromedriver\") self.driver.implicitly_wait(10) self.verificationErrors = [] self.accept_next_alert = True self.url = \"https://www.amazon.com/s?ie=UTF8&amp;page=1&amp;rh=n%3A2407749011%2Ck%3AApple&amp;page=1\" self.driver.get(self.url) self.data = [] #q1(1) self.detail_urls = [] #qi(5) def fanye(self): next_page_button = self.driver.find_element_by_xpath(\"//a[@id='pagnNextLink']\") next_page_button.send_keys(\"\\n\") #q1(3) def get_single_page(self): lists = self.driver.find_elements_by_css_selector(\"li[id^='result_']\") #print(len(lists),lists) for li_element in lists[0:20]: manufacturer, screen_size, product_dimensions_text, rating_content,\\ reviews_content, more_offer_text, offer_Price, display_type_text, product_detail = [None] * 9 try: manufacturer = li_element.find_elements_by_xpath( \".//div[@class='a-fixed-left-grid-col a-col-right']/div/div\")[1].text if \"by Apple\" not in manufacturer: continue except Exception as e: manufacturer = None #print(\"ERROR: find manufacturer has something error: \", e) try: url_detail_in_div = li_element.find_element_by_xpath( \".//div[@class='a-fixed-left-grid-col a-col-right']/div/div/a[contains(@title, 'Apple')]\") detail_url_ = url_detail_in_div.get_attribute(\"href\") product_detail = url_tile = url_detail_in_div.get_attribute(\"title\") if \"slredirect\" in detail_url_: continue # print(detail_url_) self.detail_urls.append(detail_url_) js = 'window.open(\"&#123;&#125;\");'.format(detail_url_) self.driver.execute_script(js) handles = self.driver.window_handles for handle in handles: if handle != self.driver.current_window_handle: self.driver.switch_to_window(handle) break try: table1 = self.driver.find_elements_by_xpath(\"//table[@id='HLCXComparisonTable']/tbody/tr\") for tr in table1: html1 = tr.get_attribute(\"innerHTML\") if \"Screen Size\" in html1: td_inches = tr.find_elements_by_xpath(\".//td\")[0] screen_size = td_inches.text # print(screen_size) break except Exception as e: pass #print(\"ERROR: find screen_size has something error: \", e) #q1(4) try: table2 = self.driver.find_elements_by_xpath(\"//table[@id='productDetails_detailBullets_sections1']/tbody/tr\") for tr in table2: html2 = tr.get_attribute(\"innerHTML\") if \"Product Dimensions\" in html2: product_dimensions_html = tr.find_elements_by_xpath(\".//td\")[0] product_dimensions_text = product_dimensions_html.text # print(product_dimensions_text) continue if \"Customer Reviews\" in html2: rating_html = tr.find_element_by_xpath(\".//td\") rating_text = rating_html.text reviews_text, rating_content = rating_text.split(\"\\n\") reviews_content = reviews_text.split(\" \")[0] # print(rating_content) # print(reviews_content) continue except Exception as e: pass #print(\"ERROR: find product_dimensions_text rating_content reviews_content, some problems \",e) self.driver.close() self.driver.switch_to_window(handles[0]) # print(product_detail) # print(\"\\n\") except Exception as e: pass #print(\"ERROR: get item detail url pages has problems\", e) # break try: more_offer_html = li_element.find_element_by_css_selector(\"a[href*='offer-listing']\") more_offer_text = more_offer_html.text # print(\"more_offer_text is: \", more_offer_text) # print(more_offer_html.get_attribute('innerHTML')) except Exception as e: pass #print(\"ERROR: more_offer has problem: \", e) try: offer_price_html = li_element.find_element_by_xpath(\".//span[@class='sx-price sx-price-large']\") offer_Price = offer_price_html.text # print(offer_Price) except Exception as e: pass #print(\"ERROR: find offer_Price has problem: \", e) try: display_type_html = li_element.find_elements_by_xpath( \".//dl[@class='a-definition-list a-vertical s-padding-left-base']/li/span[@class='a-list-item a-size-small a-color-secondary']\") for _span in display_type_html: if \"Display Type:\" in _span.text: display_type_html = _span.text display_type_text = display_type_html.split(\":\")[1] break except Exception as e: pass #print(\"ERROR: find display_type has problem: \", e) # print(\"\\n\") # break _tmp_dt = [manufacturer, screen_size, product_dimensions_text, rating_content, reviews_content, more_offer_text, offer_Price, display_type_text, product_detail, None, None] print(_tmp_dt) self.data.append(_tmp_dt) time.sleep(random.randint(0,2)) def main(self): i=0 while True and i&lt;=4: self.get_single_page() try: i=i+1 self.fanye() except: break return self.data,self.detail_urlsa = Spider()dt, url_lists = a.main()print(url_lists)col_name = [\"Manufacturer\", \"Display_Size\", \"Display_Dimensions\", \"Rating\", \"Number_of_Review\", \"More_Offer\", \"Offer_Price\", \"Display_Type\", \"Product_detail\", \"Special_Feature\", \"Special_Offer\"]df = pd.DataFrame(dt,columns=col_name)#df=df.rename(columns=col_name)print(df)","categories":[],"tags":[]},{"title":"Ubuntu下minicom使用教程","slug":"Ubuntu下minicom使用教程","date":"2019-01-21T10:12:45.000Z","updated":"2019-01-30T08:19:20.572Z","comments":true,"path":"2019/01/21/Ubuntu下minicom使用教程/","link":"","permalink":"https://cloudthink.github.io/2019/01/21/Ubuntu下minicom使用教程/","excerpt":"","text":"1.安装1#sudo apt-get install minicom 2.配置与使用1#sudo minicom -s 选择Serial port setup，如果要调试usb串口，设置Serial Device为/dev/ttyUSB0，然后设置Hardware Flow Contrl 为No，回车，Exit。","categories":[],"tags":[]},{"title":"理解RNN与LSTM神经网络","slug":"理解RNN与LSTM Networks","date":"2019-01-21T10:12:45.000Z","updated":"2019-01-30T10:10:33.324Z","comments":true,"path":"2019/01/21/理解RNN与LSTM Networks/","link":"","permalink":"https://cloudthink.github.io/2019/01/21/理解RNN与LSTM Networks/","excerpt":"","text":"Recurrent Neural Networks人类不会每时每刻都开始思考。当你阅读这篇文章时，你会根据你对之前单词的理解来理解每个单词。你不会立刻忘记之前读的所有东西，然后再从头开始思考。你的想法有持久性。 传统的神经网络无法做到这一点，这似乎是其一个主要的缺点。例如，假设您想要对电影中每个时间点发生的事件进行分类。目前尚不清楚传统神经网络如何利用其对电影中先前事件的记录来影响之后发生的事情。 循环神经网络解决了这个问题。它们是带有循环的网络，允许信息持续存在。 Recurrent Neural Networks的循环结构在上图中，一块神经网络A查看一些输入xt并输出一个值ht。循环允许信息从网络的一个步骤传递到下一个步骤。这个循环使得循环神经网络看起来有点神秘。但是，如果你再想一下，事实证明它们与普通的神经网络并没有什么不同。可以将循环神经网络视为同一网络的多个副本，每个副本都将消息传递给后继者。如果把RNN神经网络展开： 展开的RNNs网络 这种类似链的性质表明，递归神经网络与序列和列表密切相关。它们是用于此类数据的神经网络的自然架构。 他们肯定会被使用！在过去几年中，将RNN应用于各种问题取得了令人难以置信的成功：语音识别，语言建模，翻译，图像字幕……这个列表还在继续。我将讨论使用RNNs可以实现的惊人壮举，以及Andrej Karpathy的博客文章，但他们真的很棒。 这些成功的关键在于使用“LSTM”，这是一种非常特殊的递归神经网络，对于许多任务而言，它比标准版本好得多。几乎所有基于递归神经网络的令人兴奋的结果都是用它们实现的。这篇文章将探讨这些LSTM。 长期依赖（Long-Term Dependencies）问题RNN的一个吸引力是他们可能能够将先前信息连接到当前任务，例如使用先前的视频帧可能推动对当前帧的理解。如果RNN可以做到这一点，它们将非常有用。但他们可以吗？这取决于很多依赖因素。 有时，我们只需要查看最近的信息来执行当前任务。例如，考虑一种语言模型，试图根据之前的单词预测下一个单词。如果我们试图预测“the clouds are in the [sky]”的最后一个词，我们并不需要任何其他的上下文 - 很明显下一个词将是天空。在这种情况下，如果相关信息与所需信息之间的差距很小，则RNN可以学习使用过去的信息。 但也有一些情况需要更多的背景。考虑尝试预测文本中的最后一个词“我I grew up in France… I speak fluent French.” 最近的信息表明，下一个词可能是一种语言的名称，但如果我们想缩小具体是哪种语言的范围，我们需要从更进一步的背景来看，法国的背景。相关信息与需要变得非常大的点之间的差距是完全可能的。 不幸的是，随着差距的扩大，RNNs无法学习连接信息。 理论上，RNNs绝对能够处理这种“长期依赖性”。人类可以仔细挑选参数来解决这种形式的玩具问题。遗憾的是，在实践中，RNN似乎无法学习它们。 Hochreiter（1991）[德国]和Bengio 等人（1994）对该问题进行了深入探讨。他找到了一些为什么它可能很困难的根本原因。 值得庆幸的是，LSTM没有这个问题！ LSTM Networks长短期内存网络 - 通常只称为“LSTM” - 是一种特殊的RNN，能够学习长期依赖性。 它们是由Hochreiter＆Schmidhuber（1997）介绍的，并且在下面的工作中被许多人精炼和推广。他们在各种各样的问题上工作得非常好，现在被广泛使用。 LSTM明确旨在避免长期依赖性问题。长时间记住信息实际上是他们的默认行为，而不是他们难以学习的东西！ 所有递归神经网络都具有神经网络重复模块链的形式。在标准RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。 The repeating module in a standard RNN contains a single layer LSTM也具有这种类似链的结构，但重复模块具有不同的结构。RNNs只有一个神经网络层，而LSTM只有四个。以一种非常特殊的方式进行交互。 The repeating module in an LSTM contains four interacting layers不要担心发生了什么的细节。我们将逐步介绍LSTM图。现在，让我们试着对我们将要使用的符号感到满意。 在上图中，每一行都携带一个整个向量，从一个节点的出到其他节点的输入。粉色圆圈表示逐点运算，如矢量加法，而黄色框表示神经网络层。行合并表示连接，而行分叉表示其内容被复制，副本将转移到不同的位置。 The Core Idea Behind LSTMsLSTM的关键是单元状态，水平线贯穿图的顶部。 电池状态有点像传送带。 它直接沿着整个链运行，只有一些次要的线性交互。 信息很容易沿着它不变地流动。 LSTM具有删除或添加信息到细胞状态的功能，由门(gates)这种结构对这两种操作进行精确的调节。 门是一种控制信息能否通过的方式。 它们由sigmoid形神经网络层和逐点乘法运算组成。 sigmoid层输出0到1之间的数字，描述每个组件应该通过多少信息。 值为零意味着“不让任何东西通过”，而值为1则意味着“让一切都通过！” LSTM具有三个这样的门，用于保护和控制细胞的状态。 Step-by-Step LSTM Walk Through译自http://colah.github.io","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"1899-11-29T15:55:00.000Z","updated":"2019-01-30T09:47:07.723Z","comments":true,"path":"1899/11/30/hello-world/","link":"","permalink":"https://cloudthink.github.io/1899/11/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"leetcode刷题(C语言)","slug":"leetcode刷题(C语言)","date":"1899-11-29T15:55:00.000Z","updated":"2019-01-30T10:27:09.178Z","comments":true,"path":"1899/11/30/leetcode刷题(C语言)/","link":"","permalink":"https://cloudthink.github.io/1899/11/30/leetcode刷题(C语言)/","excerpt":"","text":"#9. Palindrome Number Determine whether an integer is a palindrome. An integer is apalindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 1234567891011121314151617181920bool isPalindrome(int x) &#123; if(x&lt;0) return false; else&#123; int nums[999]; int i=0; while(x!=0)&#123; nums[i]=x%10; x=x/10; i++; &#125; for(int j=0;j&lt;i/2;j++)&#123; if(nums[j]!=nums[i-j-1])&#123; return false; break; &#125; &#125; return true; &#125;&#125; #21. Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The newlist should be made by splicing together the nodes of the first twolists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode *p,*q,*newlist,*r; p=l1;q=l2; if(p==NULL)&#123; return q; &#125;else if(q==NULL)&#123; return p; &#125; if(l2-&gt;val &gt; l1-&gt;val) &#123; newlist=l1; p=l1-&gt;next; &#125;else&#123; newlist=l2; q=l2-&gt;next; &#125; r=newlist; while(p!=NULL &amp;&amp; q!=NULL)&#123; if(p-&gt;val &gt; q-&gt;val) &#123; r-&gt;next=q; q=q-&gt;next; &#125;else&#123; r-&gt;next=p; p=p-&gt;next; &#125; r=r-&gt;next; &#125; if(p==NULL)&#123; r-&gt;next=q; &#125;else&#123; r-&gt;next=p; &#125; return newlist; &#125; #796. Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmostcharacter to the rightmost position. For example, if A = ‘abcde’, thenit will be ‘bcdea’ after one shift on A. Return True if and only if Acan become B after some number of shifts on A. Example 1: Input: A = ‘abcde’, B = ‘cdeab’ Output: true Example 2: Input: A = ‘abcde’, B = ‘abced’ Output: false Note: A and B will have length at most 100. 1234567891011121314151617181920212223242526272829bool rotateString(char* A, char* B) &#123; int lena=strlen(A); int lenb=strlen(B); char *newa=A; char tempc; int j=0; if(lenb!=lena) return false; else if(strcmp(A,B)==0)&#123; return true; &#125; //printf(\"%s\\n\", A); while(j&lt;lena)&#123; tempc=newa[0]; for (int i = 0; i &lt; lena-1; i++) &#123; newa[i]=newa[i+1]; &#125; newa[lena-1]=tempc; //printf(\"%s,%s\\n\",newa,B ); if(strcmp(B,newa)==0)&#123; //printf(\"find\\n\"); return true; &#125; j++; &#125; return false; &#125;","categories":[],"tags":[]}]}